	一般做数据库相关开发的, 除非学习用, 否则很少有人直接使用JDBC， 通常都会使用一些框架/库。而且开源市场上的选择也比较多，就我个人接触到的就有：Hibernate，Mybatis，JdbcTemplate，DbUtils，ActiveRecord，JavaLite等等。 这些框架能大幅的提高开发效率，特别对于一些基本的单表的操作来说，虽然各有差异，但总的来说已经够用了。
	然而稍微复杂点的应用总会碰到需要手工拼接SQL的问题 ，这里要讨论的不是SQL拼接的问题，而是对SQL查询结果的映射问题。 通常我们在写完SQL的查询代码后， 还需要写一个对应的结果类，将查询的数据映射到这个结果类，以便于后续的程序能够更好的使用这些数据。存储查询结果的方式通常有2种：
	 
	一种简单的方式是把结果数据都放到一个Map对象中：这种方式很轻便，但是这样会带来2个的问题：
	*调用者需要知道Map里面的每个key的名称，也就是会给程序员带来所谓的记忆负担；
	*SQL语句更改导致Key发生变化后，由于无法得到编译器的帮助，出现了问题也比较难以发现，需要程序员非常小心的处理这些更改。 
	
	手工书写这些结果类，将SQL查询的字段一个个翻译成Java字段： 这种方式的好处是调用者可以很轻松的使用这些数据, 但是也存在2个问题：
	*书写这些字段很枯燥乏味，特别是字段很多的时候更是如此，对我这种有着多年开发经历的程序员来说，有种苦不堪言的感觉。
	*SQL的语句更改同样也会牵涉到修改这个结果类，比Map好点的是，由于IDE的帮助，所有牵涉到这些数据变更的地方能够很容易发现和修正。
	
	如果有一种方法能够在我们写完SQL查询代码后，就能够自动的处理这些SQL语句，帮助我们自动的生成对应的结果类；并且当SQL修改后也能自动的更新这个结果类。这样，一方面解决了手工书写的麻烦，我们可以把更多时间和精力放在处理那些更重要的事情上；另一方面，当我们需要修改SQL导致某个字段发生更改时， 由于自动生成的结果类也会同步修改， 编译器就会自动给出提示：引用无效的字段。  使得问题一产生就能立即得到修复，省去了很多潜在的问题。
	想象总是很完美，现实总是很残酷! 到底能否实现上面的想法呢，我们来具体分析下： 
	要做到自动产生结果类,其核心就是要拿到我们书写的SQL查询所对应列名和数据类型。有了列名和数据类型，就很容易写一个方法来产生结果类了。一般情况下，在SQL查询写完之后，包括调用存储过程和那些根据调用参数来动态拼接的SQL(通常是动态组装过滤/分组/排序/连接表等)，其查询结果的字段部分都是相对固定的。也有极少情况下会碰到字段都不确定的SQL查询，当然这种极端情况下，也没法手工写这个结果类了，反倒是用Map更合适, 我们这里不做讨论。
	一种方案是直接分析SQL代码中 SELECT部分的字段， 这个方案的局限性很大:
	*对于拼接的SQL，分析难度比较大
	*字段的类型也无法判断
	*SELECT * ...; SELECT a.*,b.name ...; CALL statement 这样常见的查询基本上无法处理。 
	 
	另一种方案是直接运行我们的SQL代码:
	我们知道JDBC执行一个SQL查询，会返回一个ResultSet对象，通过该对象中方法getMetaData()，能够得到这次查询的一些元数据：如列名称，列类型，以及该列所属的表名等, 这些信息已经足够我们来产生需要的那个结果类了. 
	不过，这里存在一个问题，对于那些固定的SQL语句还好说，我们拿到这个固定的SQL，然后调用JDBC，就能获取到该SQL的MetaData，然后就可以很容易的根据这些信息来产生结果类。但是，对于那些复杂的牵涉到一系列根据参数来动态产生的SQL查询，在设置好参数前是无法直接运行的，所以就无法得到MetaData，得不到MetaData我们就无法往下一步走。
	怎么办？
	前面已经讨论了，对于动态SQL，无论输入什么样的参数，虽然最终产生的SQL语句可能是不一样的，但是最终产生结果列却是固定的。 我们当前需要解决的问题不正是要获取这些固定的列信息吗？ 至于实际上执行的到达时什么样的SQL，那是运行环境的事情，和我们现在要解决的问题没有什么关系. 
	到这里聪明的读者一定会想到，既然如此，那我们就构造一系列缺省的参数值，这些参数并没有实际用处，仅仅是为了让我们的SQL得以正常运行，这样就可以拿到需要的MetaData. 
	好了，终于拿到了MetaData，接下来生成结果类的事情就很简单了：
	ResultSetMetaData rsmd = rs.getMetaData();
	int cc = rsmd.getColumnCount();
	for (int i = 1; i <= cc; i++) {
		String fieldType = TypeHelper.getJavaType(rsmd.getColumnType(i)); //JDBC数据类型转Java类型
		String fieldName = rsmd.getColumnLabel(i); //as 别名
		if (fieldName == null || fieldName.trim().length() < 1) {
			fieldName = rsmd.getColumnName(i);
		}
		
		writeToJava("private "+fieldType+" "+fieldName+";");
		...
	}

	等等，这里还忽略一个细节，我们书写SQL，通常有2种形式，一是直接在代码中， 另外一种是些在配置文件中。 对于配置文件这种形式，由于里面的主要任务就是组装SQL， 这种情况下，按照约定的文件格式，还是能够比较容易的分析出要运行的SQL语句，然后按上面的思路执行就可以了。 但是对代码中拼接的SQL， 要想获取到能运行的SQL，就比较难了。至于配置文件形式的SQL和代码中写SQL这2种形式哪种更好，这里暂时不做细究，我会单独找个地方来讨论。这里主要讨论下代码中写SQL的情况下，如何来自动产生结果类。
	获取代码中的动态SQL的思路和前面的也差不多，就是构造出缺省的参数，然后直接调用Class的里面的方法，然后截获调用SQL代码。 怎么截获？ 
	
	monalisa-db实现了对数据库的一些操作，其Eclipse插件同时也带来了以下几个便利：
	*对@DB注解的接口，在文件保存时 ，就可以立即自动的生成基本表的CRUD操作
	
	*对@Select注解的方法，在文件保存时 ，就可以立即自动的生成结果类
	
	*代码中书写SQL，最头痛的事情之一就是 换行连接，字符转义的问题。 使得大段的SQL代码写起来满分，看着也不舒服。多行字符串书写将会非常轻松
	System.out.println(""/**~{
	    SELECT * 
	    	FROM user
	    	WHERE name="zzg"
	}*/);
	
	将会输出：
	SELECT * 
	    FROM user
	    WHERE name="zzg"
	    
	关于多行语法的更多细节可以参考: [这里](https://github.com/11039850/monalisa-db/wiki/Multiple-line-syntax)    
	
	
	*代码中的SQL类可以当着配置文件一样看待，能够动态更新。
	和一般的ClassLoader实现的动态加载不同，特别是对web应用，会导致整个web应用重启，然后重新初始化，启动缓慢；它采用Java的agentmain机制，实现代码的热替换，更新非常迅速。
	 
	
	 
	接下来重点讨论下monalisa-db的这个插件具体是如何实现自动生成结果类的：
	要实现将代码中的SQL自动结果类的话，还存在相当的一些挑战：
	*如何定义类名：
	*如何执行代码： 记住，这个时候结果类还没有产生
	*如何得到SQL语句
	*如何自动修改代码： 结果类产生后，需要修改代码，使得代码的输出接口是我们新产生的这个结果类
	*如何检测SQL变更
	
	*结果类名如何定义
	为了最简化的处理这个问题，@Select提供了2中方式，默认采用定义该方法的 全路径类名做为包名，Result+方法名作为类名；也可以通过name参数指定类名
	
	*在结果类尚未产生的情况下，如何执行代码得到SQL语句
	约定使用泛值来书写该方法， 函数的返回值 和 查询结果 泛值的对应关系分三类如下：：
	 //1. List查询
    //public DataTable   method_name(...){... return Query.getList();   }    或
    //public List        method_name(...){... return Query.getList();   }    
    //
    //2. Page查询
    //public Page   method_name(...){... return Query.Page();      }
    //
    //3. 单条记录
    //public Object method_name(...){... return Query.getResult(); }
	
	*如何自动修改代码，使得代码的输出接口是我们新产生的这个结果类
	
	
	在Eclipse下当一个Java文件保存后，会出发Save Actions事件，然后截获该事件实现一个叫ICleanUpFix的接口，里面返回的是一系列的修改信息(偏移量，长度，替换的内容）
	
	
	为了方便开发，理想的情况下是SQL文件一保存，就能够立即的生成结果类， 这样还有一个特别的好处， 就是我们在编辑的时候，就能够知道写的SQL有没有问题。要实现这一点
	
	 
	
	
	